#include <Arduino.h>
#include <Adafruit_TinyUSB.h>  // for Serial
#include <Wire.h>
#include <SparkFun_VL53L5CX_Library.h>  //http://librarymanager/All#SparkFun_VL53L5CX

SparkFun_VL53L5CX myImager;
VL53L5CX_ResultsData measurementData;  // Result data class structure, 1356 byes of RAM

int imageResolution = 0;  
int imageWidth = 0;       
int number=0;
int image_frequency=10; //Hz
int time_ISR= 100; //ms
int STATE1 = 0; // hypoteticcaly we'll have also STATE 2 and STATE3 for the other 2 TOFs
// STATE 0:  controllo
// STATE 11: allerta 1 livello
// STATE 12: allerta 2 livello
// STATE 2:  allarme
int sampling=0; //set the 2 modes of sampling
// sampling 0 : chess
// sampling 1 : all the matrix

SoftwareTimer blinkTimer; //timer used for ISR

float distanceMatrix[imageWidth][imageWidth];
float distanceMatrixpast[imageWidth][imageWidth];
float relativespeed

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("SparkFun VL53L5CX Imager Example");
  ////////////////////////////////////////////////////// SET IMAGE SENSOR /////////////////////////////////////////////////// 
  Wire.begin();           //This resets to 100kHz I2C
  Wire.setClock(400000);  //Sensor has max I2C freq of 400kHz

  Serial.println("Initializing sensor board. This can take up to 10s. Please wait.");
  if (myImager.begin() == false) {
    Serial.println(F("Sensor not found - check your wiring. Freezing"));
    while (1)
      ;
  }

  myImager.setResolution(8 * 8);  //Enable all 64 pads

  imageResolution = myImager.getResolution();  //Query sensor for current resolution - either 4x4 or 8x8
  imageWidth = sqrt(imageResolution);          //Calculate printing width

  //Using 4x4, min frequency is 1Hz and max is 60Hz
  //Using 8x8, min frequency is 1Hz and max is 15Hz
  bool response = myImager.setRangingFrequency(image_frequency);
  if (response == true)
  {
    int frequency = myImager.getRangingFrequency();
    if (frequency > 0)
    {
      Serial.print("Ranging frequency set to ");
      Serial.print(frequency);
      Serial.println(" Hz.");
    }
    else
      Serial.println(F("Error recovering ranging frequency."));
  }
  else
  {
    Serial.println(F("Cannot set ranging frequency requested. Freezing..."));
   while(1);
  }
  myImager.startRanging();

  ///////////////////////////////////////////////////////// SET TIMER ///////////////////////////////////////////////////
  // Configure the timer with 100 ms interval and define the callback
  blinkTimer.begin(time_ISR, blink_timer_callback);

  // Start the timer
  blinkTimer.start();
}

void sampling_chess()
{

}

void sampling_total()
{
  //get, save and print the data
      for (int y = 0; y < imageWidth; y++) //rows 
      {
        for (int x = 0; x < imageWidth; x++) //column
        {
          int index = x + (y * imageWidth);
          distanceMatrix[y][x] = measurementData.distance_mm[index];
          Serial.print(distanceMatrix[y][x]);
          Serial.print("\t");
        }
        Serial.println();
      }
      Serial.println();
      }
      //Check the data
}

void loop() 
{
  /////////////////////////////////////////STATE MACHINE for TOF 1//////////////////////////////////////////////////////
  //After the set up, the state is automatically set at 0 = CONTROLLO
  switch(STATE1)
  {
    case 0:
      //CONTROLLO
      sampling=0;
    break;
    
    case 11:
      //ALLERTA 1 LIVELLO
      sampling=1
    break;

    case 12:
      //ALLERTA 2 LIVELLO
    break;

    case 2:
      //ALLARME
    break;
  }

}
/*
void blink_timer_callback(TimerHandle_t xTimerID)
{
  // freeRTOS timer ID, ignored if not used
  (void) xTimerID;
  if (myImager.isDataReady() == true)
  {
    if (myImager.getRangingData(&measurementData)) //Read distance data into array
    {
      //The ST library returns the data transposed from zone mapping shown in datasheet
      //Pretty-print data with increasing y, decreasing x to reflect reality
      for (int y = 0 ; y <= imageWidth * (imageWidth - 1) ; y += imageWidth)
      {
        for (int x = imageWidth - 1 ; x >= 0 ; x--)
        {
          Serial.print("\t");
          Serial.print(measurementData.distance_mm[x + y]);
        }
        Serial.println();
      }
    }
  }
  
}
*/

void blink_timer_callback(TimerHandle_t xTimerID) 
{
  (void)xTimerID;
  number=number+1; //check flag

  if (myImager.isDataReady() == true)
  {
    if (myImager.getRangingData(&measurementData)) 
    {
      Serial.println(number);
      switch(sampling)
      {
        case 0:
          //get the data as a chess board
          sampling_chess();
        break;

        case 1:
          //get all the data
          sampling_total();
        break; 
      }
    }
  }
}
